# volatile的定义

> Java允许线程访问共享变量, 为了确保共享变量能被准确和一致性的更新, 线程应该通过排他锁单独获得这个变量。Java提供了volatile, 在某些情况下比锁要更加方便。如果一个字段被声明成volatile, Java线程内存模型(JMM)确保所有线程看到的这个变量的值是一致的。

# volatile实现原理

## CPU术语定义

- 内存屏障(memory barriers) : 是一组处理器指令, 用于实现对内存操作的顺序限制
- 缓冲行(cache line) : 缓存中可以分配的最小存储单元。处理器填写缓存线时会加载整个缓存线, 需要使用多个主内存读周期
- 原子操作(atomic operations) : 不可中断的一个或一系列操作
- 缓存行填充(cache line fill) : 当处理器识别到从内存中读取操作数是可缓存的, 处理器读取整个缓存行到适当的缓存
- 缓存命中(cache hit) : 如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时, 处理器从缓存中读取操作数, 而不是从内存读取
- 写命中(write hit) : 当处理器的操作数写回到一个内存缓存的区域时, 它首先会检查这个缓存的内存地址是否在缓存行中, 如果存在一个有效的缓存行, 则处理器将这个操作数写回到缓存, 而不是写回到内存, 这个操作被称为写命中
- 写缺失(write misses the cache) : 一个有效的缓存行被人写入到不存在的内存区域

## volatile的两条实现原则

- Lock前缀指令会引起处理器缓存回写到内存

  > Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存。但是，在最近的处理器里，LOCK＃信号一般不锁总线，而是锁缓存，毕竟锁总线开销的比较大。

- 一个处理器的缓存回写到内存会导致其他处理器的缓存无效